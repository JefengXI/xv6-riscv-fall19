# util lab
## 该分支内实现了MIT-6.s081-OS lab lock的bio和kalloc,具体代码文件位于kernel文件夹下的bio.c和kalloc.c

## 各实验注意点如下:

#### kalloc.c

#### 主要并发限制在于多个CPU共同使用一个内存链表，故选择多个CPU独立使用自己的内存链表。

#### 故可在原有的kalloc.c的基础上将使用的kmem，变为kmems[NCPU]，在使用kget/kfree时通过cpuid()获取当前是哪个cpu调用，通过该值选用特定的kmems即可。

#### 需要注意cpuid()方法在使用时需要在前加上push_off()，在后加上pop_off()。

#### 此外由于初始化内存链表数组时只对第一个链表进行初始化，故而若第n(n不为1)个CPU访问时会无法获取到内存，故需要从其他CPU内存链表中窃取一个可用内存，放入自己的链表中。这个过程注意加锁和释放锁的处理。



#### 可行的奇怪方法----在初始化内存链表时，尝试初始化每个CPU的内存链表，这样或许可以不实现窃取内存也可以实现要求。但是和实验目的有冲突。



#### bio.c

#### 问题同kalloc.c类似，但是由于缓存数据块是多个CPU间共享的，故不能使用各个CPU分配自己的链表这个做法。但可以通过hash表来人为地区分。

#### 故可在原有的bio.c的基础上将使用的head，变为hashbucket[NBUCKETS]，由于使用了多个哈希桶，故还需要将锁的数量变为lock[NBUCKETS]。

#### 其他流程同kalloc基本一致，也是抢占其他哈希桶的缓冲块到自身的哈希桶中，但由于这里使用的是双向链表，具体操作有些许不同。

#### 可行的奇怪方法----在初始化哈希桶时，尝试初始化每个哈希桶，这样可以不实现窃取内存也可以实现要求。但是和实验目的有冲突。